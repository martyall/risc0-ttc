use ethers_contract::EthEvent;
use ethers_core::{
    abi::{AbiDecode, AbiEncode, RawLog},
    types::{H256, U256},
};

use crate::algorithm;

pub mod contract {

    use ethers_contract::{EthCall, EthDisplay, EthEvent};

    #[derive(Clone, EthEvent, EthDisplay, Default, Debug, PartialEq, Eq, Hash)]
    #[ethevent(
        name = "TokenDetailsEmitted",
        abi = "TokenDetailsEmitted(uint256[6],uint256[][6])"
    )]
    pub struct TokenDetailsEmittedFilter {
        pub token_ids: [::ethers_core::types::U256; 6],
        pub preference_lists: [::std::vec::Vec<::ethers_core::types::U256>; 6],
    }

    #[derive(Clone, EthCall, EthDisplay, Default, Debug, PartialEq, Eq, Hash)]
    #[ethcall(name = "storeResult", abi = "storeResult(uint256[][])")]
    pub struct StoreResultCall {
        pub result: ::std::vec::Vec<::std::vec::Vec<::ethers_core::types::U256>>,
    }
}

pub fn decode_input(log_data: Vec<u8>) -> algorithm::PreferenceGraph<U256> {
    let topic_str: &str = "e58780ba0390d72735fcc7f1706d8541c5cf7cfc291290971765006618f619fb";

    let logs: RawLog = RawLog {
        topics: vec![<H256>::decode_hex(topic_str).unwrap()],
        data: log_data,
    };

    let input: contract::TokenDetailsEmittedFilter = EthEvent::decode_log(&logs).unwrap();

    let assigned_prefs = input
        .token_ids
        .iter()
        .map(|x| x.clone())
        .zip(input.preference_lists);

    let prefs = algorithm::Preferences::new(assigned_prefs.into_iter().collect()).unwrap();

    algorithm::PreferenceGraph::new(prefs).unwrap()
}

pub fn encode_output(output: &algorithm::Solution<U256>) -> Vec<u8> {
    let abi_output = output.res.iter().map(|x| x.values.clone()).collect();
    let call = contract::StoreResultCall { result: abi_output };
    let mut bs = call.encode();
    // drop the selector to just get the data part
    bs.drain(0..4);
    bs
}

#[cfg(test)]
mod tests {

    use algorithm::Cycle;
    use hex::FromHex;

    use super::*;

    #[test]
    fn basic_test() {
        let log_str: &str =
        "000000000000000000000000000000000000000000000000000000000008b8ec000000000000000000000000000000000000000000000000000000000003297e000000000000000000000000000000000000000000000000000000000002e0c700000000000000000000000000000000000000000000000000000000000be507000000000000000000000000000000000000000000000000000000000009aea2000000000000000000000000000000000000000000000000000000000005985200000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000024000000000000000000000000000000000000000000000000000000000000002e000000000000000000000000000000000000000000000000000000000000003600000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000002e0c7000000000000000000000000000000000000000000000000000000000009aea200000000000000000000000000000000000000000000000000000000000be5070000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000002e0c7000000000000000000000000000000000000000000000000000000000008b8ec0000000000000000000000000000000000000000000000000000000000059852000000000000000000000000000000000000000000000000000000000003297e0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000002e0c7000000000000000000000000000000000000000000000000000000000003297e0000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000008b8ec0000000000000000000000000000000000000000000000000000000000059852000000000000000000000000000000000000000000000000000000000009aea200000000000000000000000000000000000000000000000000000000000be5070000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000003297e000000000000000000000000000000000000000000000000000000000002e0c7000000000000000000000000000000000000000000000000000000000008b8ec0000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000008b8ec000000000000000000000000000000000000000000000000000000000009aea200000000000000000000000000000000000000000000000000000000000be5070000000000000000000000000000000000000000000000000000000000059852";
        let log_data = <Vec<u8>>::from_hex(log_str).unwrap();

        let mut g: algorithm::PreferenceGraph<U256> = decode_input(log_data);

        let ps: Vec<Cycle<U256>> = g.solve_preferences().unwrap().res;

        assert_eq!(
            vec![
                Cycle {
                    values: vec![U256::from(188615)]
                },
                Cycle {
                    values: vec![U256::from(571628), U256::from(634530), U256::from(207230)]
                },
                Cycle {
                    values: vec![U256::from(779527), U256::from(366674)]
                }
            ],
            ps
        );
    }
}
